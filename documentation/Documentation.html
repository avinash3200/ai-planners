<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>p1 API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#p1.aStarNumNodesExpanded">aStarNumNodesExpanded</a></li>
    <li class="mono"><a href="#p1.bfsNumNodesExpanded">bfsNumNodesExpanded</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#p1.aStar">aStar</a></li>
    <li class="mono"><a href="#p1.bfs">bfs</a></li>
    <li class="mono"><a href="#p1.checkPlan">checkPlan</a></li>
    <li class="mono"><a href="#p1.cmpListNoOrder">cmpListNoOrder</a></li>
    <li class="mono"><a href="#p1.cmpListWithOrder">cmpListWithOrder</a></li>
    <li class="mono"><a href="#p1.getActionsForBlocksWorld">getActionsForBlocksWorld</a></li>
    <li class="mono"><a href="#p1.gsp">gsp</a></li>
    <li class="mono"><a href="#p1.main">main</a></li>
    <li class="mono"><a href="#p1.printDict">printDict</a></li>
    <li class="mono"><a href="#p1.printList">printList</a></li>
    <li class="mono"><a href="#p1.readFile">readFile</a></li>
    <li class="mono"><a href="#p1.writeFile">writeFile</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#p1.Action">Action</a></span>
        
          
  <ul>
    <li class="mono"><a href="#p1.Action.__init__">__init__</a></li>
    <li class="mono"><a href="#p1.Action.getStateOnActionUtil">getStateOnActionUtil</a></li>
    <li class="mono"><a href="#p1.Action.getStatesOnApplication">getStatesOnApplication</a></li>
    <li class="mono"><a href="#p1.Action.getStatesOnApplicationUtil">getStatesOnApplicationUtil</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#p1.Arg">Arg</a></span>
        
          
  <ul>
    <li class="mono"><a href="#p1.Arg.__init__">__init__</a></li>
    <li class="mono"><a href="#p1.Arg.isVariable">isVariable</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#p1.ArgTypes">ArgTypes</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#p1.PropositionTypes">PropositionTypes</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#p1.State">State</a></span>
        
          
  <ul>
    <li class="mono"><a href="#p1.State.__init__">__init__</a></li>
    <li class="mono"><a href="#p1.State.addTrueSentence">addTrueSentence</a></li>
    <li class="mono"><a href="#p1.State.getNextStates">getNextStates</a></li>
    <li class="mono"><a href="#p1.State.hasTrueSentences">hasTrueSentences</a></li>
    <li class="mono"><a href="#p1.State.isGoalState">isGoalState</a></li>
    <li class="mono"><a href="#p1.State.removeTrueSentence">removeTrueSentence</a></li>
    <li class="mono"><a href="#p1.State.setHeuristicValue">setHeuristicValue</a></li>
    <li class="mono"><a href="#p1.State.tracePath">tracePath</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#p1.TrueSentence">TrueSentence</a></span>
        
          
  <ul>
    <li class="mono"><a href="#p1.TrueSentence.__init__">__init__</a></li>
    <li class="mono"><a href="#p1.TrueSentence.getNewGoals">getNewGoals</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">p1</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1', this);">Show source &equiv;</a></p>
  <div id="source-p1" class="source">
    <pre><code>#!/usr/bin/python
# -*- coding: utf-8 -*-

# Tushar Agarwal
# Shailesh Mani Pandey

# AI Lab 4

from __future__ import print_function
import sys
from heapq import *
import time
import random

# Globals:

bfsNumNodesExpanded = 0
"""
This variable keeps track of total number of nodes expanded in breadth-first search.
"""

aStarNumNodesExpanded = 0
"""
This variable keeps track of total number of nodes expanded in A-Star search.
"""

class ArgTypes:

    """
    This class contains constants for different types of arguments.
    """

    VARIABLE = 0
    TERMINAL = 1


class Arg:
    """
    This class represents an argument.
    """

    def __init__(
        self,
        argType,
        argValue,
        isNegation,
        ):
        """
        Initializes the argument using `argType` and `argValue`.
        """

        self.type = argType
        """
        Type of the argument.
        """

        self.value = argValue
        """
        Value of the argument.
        """

        self.isNegation = isNegation
        """
        Helps in distinguishing between positive and negative literals.
        """

    def __str__(self):
        """
        Returns a human-friendly representation of
        the argument.
        """

        retStr = ''

        if self.isNegation:
            retStr += '~'

        if self.type == ArgTypes.TERMINAL:
            retStr += str(self.value).upper()
        else:
            retStr += str(self.value).lower()

        return retStr

    def isVariable(self):
        """
        Returns true if 'Arg' object is a variable.
        """

        return self.type == ArgTypes.VARIABLE

    def __eq__(self, other):
        """
        Checks the equality of two `Arg` objects.
        """

        return self.type == other.type and self.value == other.value \
            and self.isNegation == other.isNegation

    def __ne__(self, other):
        """
        Checks the inequality of two `Arg` objects.
        """

        return not self.__eq__(other)


class PropositionTypes:
    """
    This class contains constants for different types of propositions.
    """

    ON = 'on'
    ONTABLE = 'ontable'
    CLEAR = 'clear'
    HOLD = 'hold'
    EMPTY = 'empty'


class State:
    """
    This class represents the current state.
    This represents a conjuction of `TrueSentence` objects.
    """

    def __init__(self, trueSentenceList, groundTermList):
        """
        Initializes a `State` object.
        """

        self.trueSentenceList = list(trueSentenceList)
        """
        A list of objects of class TrueSentence.
        """

        self.groundTermList = list(groundTermList)
        """
        A list of ground `Arg` objects in sentences in the `trueSentenceList` list.
        """

        self.prevState = None
        """
        This variable is used to figure out a path after searching is done.
        """

        self.prevAction = None
        """
        Stores the action taken to reach to this `State`.
        """

        self.prevAssignments = None
        """
        Stores the assignments made in the previous state to reach this state.
        """

        self.prevPrintData = ''
        """
        Stores the string representing a combination of `self.prevAction`
        and `self.prevAssignments`.
        """

        self.depth = 0
        """
        Housekeeping variable used to print progress.
        """

        self.heuristicValue = 0
        """
        Value used in A-Star search.
        """

    def tracePath(self):
        """
        Trace path from initial state to `self`.
        Returns a dictionary with:
        (1) A string with actions (in order) in plan.
        (2) A list of states in the plan.
        """

        pathList = []
        current = self

        while current:
            pathList.append(current)
            current = current.prevState

        pathList.reverse()

        retStr = ''
        for state in pathList:
            retStr += state.prevPrintData + '\n'

        retDict = dict()
        retDict['outputString'] = retStr.strip()
        retDict['stateList'] = pathList

        return retDict

    def addTrueSentence(self, trueSentence):
        """
        Adds the `trueSentence` object to the state.
        """

        for arg in trueSentence.argList:
            if arg.isVariable():
                return

        for arg in trueSentence.argList:
            alreadyPresent = False
            for selfArg in self.groundTermList:
                if arg == selfArg:
                    alreadyPresent = True
                    break
            if not alreadyPresent:
                self.groundTermList.append(arg)

        self.trueSentenceList.append(trueSentence)

    def removeTrueSentence(self, trueSentenceArg):
        """
        Removes all objects "equal to" the `trueSentence` object from the state.
        """

        self.trueSentenceList = [trueSentence for trueSentence in
                                 self.trueSentenceList
                                 if not trueSentence == trueSentenceArg]

    def hasTrueSentences(self, trueSentenceList):
        """
        Checks if all the sentences in `trueSentenceList` exist in the state.
        If they do not, returns `False`.
        """

        for newSentence in trueSentenceList:
            isPresent = False
            for selfSentence in self.trueSentenceList:
                if selfSentence == newSentence:
                    isPresent = True
                    break
            if not isPresent:
                return False

        return True

    def isGoalState(self, goalState, inHeuristicMode=False):
        """
        Checks if `state` is a goal state by comparing
        it to `goalState`. Returns `True` if it is, and `False` otherwise.
        Essentially compares two states.
        """

        if not inHeuristicMode:
            return goalState == self
        else:
            return self.hasTrueSentences(goalState.trueSentenceList)

    def __eq__(self, other):
        """
        Checks equality of one `State` object with another.
        """

        return cmpListNoOrder(self.trueSentenceList, other.trueSentenceList)

    def __ne__(self, other):
        """
        Checks the inequality of two `State` objects.
        """

        return not self.__eq__(other)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the current state.
        """

        retStr = ''

        for trueSentence in self.trueSentenceList:
            retStr += str(trueSentence) + ' \n'

        retStr += 'Previous Action : ' + self.prevPrintData + '\n' \
            + str(self.prevAction)
        return retStr

    def setHeuristicValue(self, goalState, actionList):
        """
        Sets the heuristic value of this object.
        """

        # self.heuristicValue = bfs(self, goalState, actionList, True).depth

        currState = State(self.trueSentenceList, self.groundTermList)
        count = 0

        while True:
            for action in actionList:
                retList = action.getStatesOnApplication(currState, True)
                if len(retList) > 0:
                    currState = retList[0]
                count += 1
                if currState.hasTrueSentences(goalState.trueSentenceList):
                    self.heuristicValue = count
                    return

        # self.heuristicValue = currState.heuristicValue
        self.heuristicValue = count

    def getNextStates(self, actionList, inHeuristicMode=False):
        """
        Applies each action in `actionList` to the `self` state
        and returns all the states generated.
        """

        retList = []

        for action in actionList:
            retList.extend(action.getStatesOnApplication(self,
                           inHeuristicMode))

        return retList


class TrueSentence:
    """
    This class represents a sentence whose truth value is "True".
    """

    def __init__(
        self,
        propositionType,
        argList,
        isNegation=False,
        ):
        """
        Initializes a TrueSentence object.
        """

        self.propositionType = propositionType
        """
        Type of proposition.
        """

        self.argList = list(argList)
        """
        List of Arg objects for the proposition.
        """

        self.isNegation = isNegation
        """
        \"Adds\" a negation sign before the statement.
        """

        self.truthValue = False
        """
        Truth value of the statement for Goal Stack planner.
        """

    def __eq__(self, other):
        """
        Check equality of `TrueSentence` objects.
        """

        return self.propositionType == other.propositionType \
            and self.isNegation == other.isNegation \
            and cmpListWithOrder(self.argList, other.argList)

    def __ne__(self, other):
        """
        Checks the inequality of two `TrueSentence` objects.
        """

        return not self.__eq__(other)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the TrueSentence object.
        """

        resultStr = ''

        if self.isNegation:
            resultStr += '~'

        resultStr += '('
        resultStr += self.propositionType

        for arg in self.argList:
            resultStr += ' '
            resultStr += str(arg)
        resultStr = resultStr.strip()
        resultStr += ') '

        return resultStr

    def getNewGoals(self, currState, actionList):
        """
        Returns a dictionary of data required for new goals of GSP.
        Format of returned dictionary is :
            `trueSentenceList` : list of new `TrueSentence` objects.
            `action` : element of `actionList` that has to be applied.
            `assignments` : assignments used for applying returned action.
        `currState` is the current `State`.
        `actionList` is the list of possible actions in given world.
        Returns `None` if the goal is not reachable.
        """

        pickAction = actionList[0]
        unstackAction = actionList[1]
        releaseAction = actionList[2]
        stackAction = actionList[3]

        retDict = {}
        possibleActions = []
        assignments = {}

        possibleAssignments = list(currState.groundTermList)
        if self.propositionType == PropositionTypes.ON:
            nextAction = stackAction
        elif self.propositionType == PropositionTypes.ONTABLE:
            nextAction = releaseAction
        elif self.propositionType == PropositionTypes.EMPTY:
            nextAction = releaseAction
        elif self.propositionType == PropositionTypes.HOLD:
            checkSentence = TrueSentence(PropositionTypes.ONTABLE, self.argList, False)
            if currState.hasTrueSentences([checkSentence]):
                nextAction = pickAction
            else:
                nextAction = unstackAction
        elif self.propositionType == PropositionTypes.CLEAR:
            checkSentence = TrueSentence(PropositionTypes.HOLD, self.argList, False)
            if currState.hasTrueSentences([checkSentence]):
                nextAction = releaseAction
            else:
                nextAction = unstackAction
        else:
            return None

        for trueSentence in nextAction.effectList:
            if trueSentence.propositionType == self.propositionType \
                    and self.isNegation == trueSentence.isNegation:
                for ii in range(len(self.argList)):
                    assignments[trueSentence.argList[ii].value] = \
                            self.argList[ii]
                if nextAction == unstackAction:
                    if self.propositionType == PropositionTypes.HOLD:
                        for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.ON, \
                                    [self.argList[0], terminal], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break
                    elif self.propositionType == PropositionTypes.CLEAR:
                        for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.ON, \
                                    [terminal, self.argList[0]], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break
                    else:
                        return None
                elif self.propositionType == PropositionTypes.EMPTY:
                    for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.HOLD, \
                                    [terminal], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break

                break


#             for trueSentence in action.effectList:
#                 if trueSentence.propositionType == self.propositionType \
#                         and self.isNegation == trueSentence.isNegation:
#                     assignments = {}
#                     possibleAssignments = list(currState.groundTermList)
#                     for ii in range(len(trueSentence.argList)):
#                         assignments[trueSentence.argList[ii].value] = \
#                                 self.argList[ii]
#                         possibleAssignments.remove(self.argList[ii])
#                     possibleActions.append([action, assignments, possibleAssignments])

#         if len(possibleActions) == 0:
#             return None

#         random.shuffle(possibleActions)
#         nextAction = possibleActions[0][0]
#         assignments = possibleActions[0][1]
#         possibleAssignments = possibleActions[0][2]
        retDict['action'] = nextAction

        for arg in nextAction.variableTermList:
            if not assignments.has_key(arg.value):
                if len(possibleAssignments) == 0:
                    break
                randomIndex = random.randrange(0, len(possibleAssignments))
                assignments[arg.value] = possibleAssignments[randomIndex]
                possibleAssignments.pop(randomIndex)

        retDict['assignments'] = assignments

        retTrueList = []
        for trueSentence in nextAction.preconditionList:
            assignedSentence = TrueSentence(trueSentence.propositionType, \
                    trueSentence.argList, trueSentence.isNegation)
            newArgList = []
            for arg in assignedSentence.argList:
                if arg.isVariable():
                    newArgList.append(assignments[arg.value])
                else:
                    newArgList.append(arg)
            assignedSentence.argList = newArgList
            retTrueList.append(assignedSentence)

        retDict['trueSentenceList'] = retTrueList

        # print("***new***")
#         print("State:")
#         print(currState)
#         print("Input:")
#         print(self)
#         printDict(retDict)

        return retDict

class Action:

    """
    This class represents an action and applies, reverses, and
    manages all aspects of actions.
    """

    def __init__(
        self,
        name,
        argList,
        preconditionList,
        effectList,
        ):
        """
        Initializes an Action object.
        """

        self.name = name
        """
        Name of the action.
        """

        self.argList = argList
        """
        List of entities on which the action is applied.
        """

        self.preconditionList = list(preconditionList)
        """
        Preconditions: a list of TrueSentence objects
        """

        self.effectList = list(effectList)
        """
        Effects: a list of TrueSentence objects
        """

        self.variableTermList = []
        """
        A list of `Arg` objects in sentences in the `preconditionList` list.
        """

        for precondition in preconditionList:
            for arg in precondition.argList:
                alreadyPresent = False
                for selfArg in self.variableTermList:
                    if arg == selfArg:
                        alreadyPresent = True
                        break
                if not alreadyPresent:
                    self.variableTermList.append(arg)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the Action object.
        """

        retStr = 'Action : ' + self.name + '\n'
        retStr += 'Pre: '
        for item in self.preconditionList:
            retStr += str(item)
        retStr += '\n'
        retStr += 'Eff: '
        for item in self.effectList:
            retStr += str(item)
        retStr += '\n'

        return retStr

    def getStateOnActionUtil(
        self,
        stateObject,
        assignments,
        inHeuristicMode=False,
        ):
        """
        Applies `this` Action to `stateObject` with given `assignments`.
        `assignments` is the dictionary of assignments made.
        `inHeuristicMode` is the mode identifier.
        Returns a new `State` object.
        Does not modify `stateObject`.
        """

        retState = State(stateObject.trueSentenceList,
                         stateObject.groundTermList)
        for trueSentence in self.effectList:
            newTrueSentence = \
                TrueSentence(trueSentence.propositionType, [])
            groundTermList = []
            for variable in trueSentence.argList:
                savedArg = assignments[variable.value]
                # groundTermList.append(Arg(savedArg.type,
                        # savedArg.value, savedArg.isNegation))
                groundTermList.append(savedArg)

            newTrueSentence.argList = groundTermList
            if trueSentence.isNegation:
                if not inHeuristicMode:
                    retState.removeTrueSentence(newTrueSentence)
            else:
                retState.addTrueSentence(newTrueSentence)

        retState.prevAction = self
        retState.prevAssignments = dict(assignments)
        argListString = ''
        for arg in self.argList:
            argListString += ' ' + str(assignments[arg])

        retState.prevPrintData = '(' + self.name + argListString + ')'
        if inHeuristicMode:
            retState.heuristicValue = stateObject.heuristicValue + 1
        return retState

    def getStatesOnApplicationUtil(
        self,
        stateObject,
        unassignedVariableList,
        assignments,
        retList,
        inHeuristicMode=False,
        ):
        """
        Assigns groundterms to unassigned variables in `unassignedVariableList`.
        Returns a list of `State` objects possible after
        application of `this` Action to `stateObject`.
        `assignments` is a dictionary of assignments already made.
        Keys in this are `value` parameters of `Arg` objects.
        Values in this dictionary are `Arg` objects.
        `retList` is a list of `State` objects already generated.
        """

        if len(unassignedVariableList) == 0:

            effectTrueSentencesList = []
            for trueSentence in self.effectList:
                positiveGroundTermList = []
                if trueSentence.isNegation:
                    continue
                for variable in trueSentence.argList:
                    positiveGroundTermList.append(assignments[variable.value])
                effectTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                        positiveGroundTermList))

            if stateObject.hasTrueSentences(effectTrueSentencesList):
                return retList

            groundTermTrueSentencesList = []
            for trueSentence in self.preconditionList:
                groundTermList = []
                for variable in trueSentence.argList:
                    groundTermList.append(assignments[variable.value])
                groundTermTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                        groundTermList))

            if stateObject.hasTrueSentences(groundTermTrueSentencesList):
                if not inHeuristicMode:
                    retList.append(self.getStateOnActionUtil(stateObject,
                                   assignments, inHeuristicMode))
                else:
                    stateObject = \
                        self.getStateOnActionUtil(stateObject,
                            assignments, inHeuristicMode)
                    retList = [stateObject]
            return retList

        else:
            thisVariable = unassignedVariableList.pop()
            for groundTerm in stateObject.groundTermList:
                assignments[thisVariable.value] = groundTerm
                retList = self.getStatesOnApplicationUtil(stateObject,
                        unassignedVariableList, assignments, retList,
                        inHeuristicMode)
                if inHeuristicMode and len(retList) > 0:
                    stateObject = retList[0]
                assignments.pop(thisVariable.value)

            unassignedVariableList.append(thisVariable)
            return retList

    def getStatesOnApplication(self, stateObject,
                               inHeuristicMode=False):
        """
        Generates states after unification to input `stateObject`.
        Returns a list of `State` objects.
        This list may be empty.
        The argument `stateObject` is not modified.
        """

        assignments = {}
        retList = []
        return self.getStatesOnApplicationUtil(stateObject,
                self.variableTermList, assignments, retList,
                inHeuristicMode)

def gsp(startState, goalState, actionList):
    """
    Does Goal Stack planning.
    Returns a plan in the form of a list of dictionaries, in
    their logical order in the plan.
    The format of returned dictionary is:
        (1) `action` : element of `actionList` that has to be applied.
        (2) `assignments` : assignments used for applying returned action.
    No parameters used to call this function are changed.
    This function may not terminate (semi-decidable).
    """

    stack = []
    currentState = State(startState.trueSentenceList, \
                        startState.groundTermList)
    planList = []
    nBlocks = len(currentState.groundTermList)

    stack.append(goalState.trueSentenceList)
    for trueSentence in goalState.trueSentenceList:
        stack.append([trueSentence])

    while len(stack) > 0:
        # print("***new***")
        # printList(stack)
        print(str(len(planList)).zfill(3), end = "\r")
        poppedElement = stack.pop()

        if type(poppedElement) is list:

            if not currentState.hasTrueSentences(poppedElement):

                if len(poppedElement) > 1:
                    stack.append(poppedElement)
                    random.shuffle(poppedElement)
                    for trueSentence in poppedElement:
                        stack.append([trueSentence])

                else:
                    newGoalsData = poppedElement[0].getNewGoals(currentState, actionList)

                    if newGoalsData == None:
                        stack = []
                        currentState = State(startState.trueSentenceList, \
                                startState.groundTermList)
                        planList = []
                        stack.append(goalState.trueSentenceList)
                        for trueSentence in goalState.trueSentenceList:
                            stack.append([trueSentence])
                        continue

                    actionDict = dict()
                    actionDict['action'] = newGoalsData['action']
                    actionDict['assignments'] = newGoalsData['assignments']
                    stack.append(actionDict)
                    stack.append(newGoalsData['trueSentenceList'])
                    for trueSentence in newGoalsData['trueSentenceList']:
                        stack.append([trueSentence])
        else:
            action = poppedElement['action']
            assignments = poppedElement['assignments']
            currentState = action.getStateOnActionUtil(currentState, assignments)
            planList.append(poppedElement)
            # printDict(poppedElement)

    return planList

def aStar(startState, goalState, actionList):
    """
    Performs a A-Star search on states.
    Returns a `State` object which is equivalent
    to the goal state (`goalState`). A plan can be
    obtained by tracing the `prevState` pointers in states.
    """

    # pdb.set_trace()

    global aStarNumNodesExpanded
    aStarNodesExpanded = 0
    aStarQueue = []

    # Update heuristic value
    # startState.setHeuristicValue(goalState, actionList)

    heappush(aStarQueue, (startState.heuristicValue + startState.depth,
             startState))

    while len(aStarQueue) > 0:
        poppedElement = heappop(aStarQueue)
        poppedState = poppedElement[1]

        print('Searching plans of depth: ' + str(poppedState.depth),
              end='\r')

        if poppedState.isGoalState(goalState):
            return poppedState

        aStarNumNodesExpanded += 1
        neighborList = poppedState.getNextStates(actionList)

        for neighborState in neighborList:
            neighborState.prevState = poppedState
            neighborState.depth = poppedState.depth + 1

            # Update heuristic value

            neighborState.setHeuristicValue(goalState, actionList)
            heappush(aStarQueue, (neighborState.heuristicValue
                     + neighborState.depth, neighborState))

    return None


def bfs(
    startState,
    goalState,
    actionList,
    inHeuristicMode=False,
    ):
    """
    Performs a breadth-first search on states.
    Returns a `State` object which is equivalent
    to the goal state (`goalState`). A plan can be
    obtained by tracing the `prevState` pointers in states.
    """

    # pdb.set_trace()

    global bfsNumNodesExpanded
    bfsNumNodesExpanded = 0
    bfsQueue = []
    bfsQueue.append(startState)

    while len(bfsQueue) > 0:
        poppedState = bfsQueue.pop(0)
        print('Searching plans of depth: ' + str(poppedState.depth),
              end='\r')

        if poppedState.isGoalState(goalState, inHeuristicMode):
            return poppedState

        bfsNumNodesExpanded += 1
        neighborList = poppedState.getNextStates(actionList,
                inHeuristicMode)

        for neighborState in neighborList:
            neighborState.prevState = poppedState
            neighborState.depth = poppedState.depth + 1

        bfsQueue.extend(neighborList)

    return None


def cmpListWithOrder(first, second):
    """
    "Deep" compares two lists. Returns `True` of they are equal, and
    `False` otherwise.
    Order of elements in the lists matters.
    """

    if not len(first) == len(second):
        return False

    dupFirst = list(first)
    dupSecond = list(second)

    for ii, item in enumerate(dupFirst):
        if item != dupSecond[ii]:
            return False

    return True


def cmpListNoOrder(first, second):
    """
    "Deep" compares two lists. Returns `True` of they are equal, and
    `False` otherwise.
    Order of elements in the lists does not matter.
    """

    if not len(first) == len(second):
        return False

    dupFirst = list(first)
    dupSecond = list(second)

    for item in dupFirst:
        exists = False
        itemInList = None
        for other in dupSecond:
            if item == other:
                exists = True
                itemInList = other
                break

        if not exists:
            return False

        dupSecond.remove(itemInList)

    return True


def printDict(currentDict):
    """
    Prints a dictionary properly.
    """

    for key in currentDict.keys():
        print(str(key) + ': ')
        if type(currentDict[key]) is list:
            printList(currentDict[key])
        elif type(currentDict[key]) is dict:
            printDict(currentDict[key])
        else:
            print(str(currentDict[key]))

        print("")


def printList(currentList):
    """
    Prints a list properly.
    """

    print("#####")
    for item in currentList:
        if type(item) is list:
            printList(item)
        elif type(item) is dict:
            printDict(item)
        else:
            print(item, end = ", ")

    print("")

def getActionsForBlocksWorld():
    """
    Hardcoded actions for the Blocks World.
    """

    pickBlock = Action('pick', ['block'],
                       [TrueSentence(PropositionTypes.ONTABLE,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.CLEAR,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.EMPTY, [],
                       False)], [TrueSentence(PropositionTypes.HOLD,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.CLEAR,
                       [Arg(ArgTypes.VARIABLE, 'block', False)], True),
                       TrueSentence(PropositionTypes.ONTABLE,
                       [Arg(ArgTypes.VARIABLE, 'block', False)], True),
                       TrueSentence(PropositionTypes.EMPTY, [], True)])

    unstackBlockAFromTopOfBlockB = Action('unstack', ['blocka', 'blockb'
            ], [TrueSentence(PropositionTypes.ON,
            [Arg(ArgTypes.VARIABLE, 'blocka', False),
            Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.EMPTY, [], False)],
            [TrueSentence(PropositionTypes.HOLD,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.ON, [Arg(ArgTypes.VARIABLE,
            'blocka', False), Arg(ArgTypes.VARIABLE, 'blockb', False)],
            True), TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], True),
            TrueSentence(PropositionTypes.EMPTY, [], True)])

    releaseBlock = Action('release', ['block'],
                          [TrueSentence(PropositionTypes.HOLD,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False)],
                          [TrueSentence(PropositionTypes.ONTABLE,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False), TrueSentence(PropositionTypes.CLEAR,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False), TrueSentence(PropositionTypes.HOLD,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          True), TrueSentence(PropositionTypes.EMPTY,
                          [], False)])

    stackBlockAOnTopOfBlockB = Action('stack', ['blocka', 'blockb'],
            [TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.HOLD, [Arg(ArgTypes.VARIABLE,
            'blocka', False)], False)],
            [TrueSentence(PropositionTypes.ON, [Arg(ArgTypes.VARIABLE,
            'blocka', False), Arg(ArgTypes.VARIABLE, 'blockb', False)],
            False), TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.HOLD, [Arg(ArgTypes.VARIABLE,
            'blocka', False)], True),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], True),
            TrueSentence(PropositionTypes.EMPTY, [], False)])

    return [pickBlock, unstackBlockAFromTopOfBlockB, releaseBlock,
            stackBlockAOnTopOfBlockB]


def readFile(fileName):
    """
    Returns a dictionary with initial state, final state and
    the "mode" of operation as read from the `fileName` file.
    Keys in dictionary are:
    'planner', 'initState', 'goalState'.
    """

    retDict = {}

    with open(fileName) as inFile:

        # pdb.set_trace()

        lines = inFile.readlines()
        lines = [line.strip() for line in lines]

        try:
            numberBlocks = int(lines[0])
        except ValueError:
            print('Please tell me the number of blocks!')
            return None
        completeBlockList = []
        for i in range(1, numberBlocks + 1):
            completeBlockList.append(Arg(ArgTypes.TERMINAL, i, False))

        validPlanners = ['f', 'a', 'g']
        if not lines[1] in validPlanners:
            print("Oh! Looks like you want a planner that we don't have!"
                  )
            return None
        retDict['planner'] = lines[1]

        if not lines[2] == 'initial':
            print("Don't know from where the initial state starts!")
            return None
        initState = State([], [])
        words = lines[3].split()
        argList = []
        propositionType = None
        for word in words:
            if word[0] == '(':
                argList = []
                propositionType = word.strip('(')
            else:
                try:
                    argList.append(completeBlockList[int(word.strip(')'
                                   )) - 1])
                except:
                    print("Sorry! Can't read the file!")
                    return None
            if word[-1] == ')':
                initState.addTrueSentence(TrueSentence(propositionType.strip(')'
                        ), argList))

        retDict['initState'] = initState

        if not lines[4] == 'goal':
            print("Don't know from where the goal state starts!")
            return None

        goalState = State([], [])
        words = lines[5].split()
        argList = []
        propositionType = None
        isNegation = False
        for word in words:
            if word[0] == '~':
                isNegation = True
                word = word.strip('~')

            if word[0] == '(':
                argList = []
                propositionType = word.strip('(')
            else:
                try:
                    argList.append(completeBlockList[int(word.strip(')'
                                   )) - 1])
                except:
                    print("Sorry! Can't read the file!")
                    return None
            if word[-1] == ')':
                goalState.addTrueSentence(TrueSentence(propositionType.strip(')'
                        ), argList, isNegation))
                isNegation = False

        retDict['goalState'] = goalState
        return retDict


def writeFile(fileName, numActions, outputString):
    """
    Writes `outputString` to the given file.
    `fileName` is the pathname of the file to write to.
    """

    f = open(fileName, 'w')
    f.write(str(numActions) + '\n')
    f.write(outputString)
    f.close()


def main():
    """
    Take input argument (a file name), and write soduko solutions
    to a file.
    """

    if len(sys.argv) < 2:
        print('Invalid/insufficient arguments!')
    else:
        actionList = getActionsForBlocksWorld()
        fileName = str(sys.argv[1])
        readData = readFile(fileName)
        traceData = None
        outputString = ''
        numActions = 0
        numNodesExpanded = 0
        global bfsNumNodesExpanded
        global aStarNodesExpanded
        bfsNumNodesExpanded = 0
        aStarNodesExpanded = 0

        initTime = time.time()

        if readData['planner'] == 'f':
            bfsData = bfs(readData['initState'], readData['goalState'],
                          actionList)
            traceData = bfsData.tracePath()
            outputString = traceData['outputString']
            numActions = len(traceData['stateList']) - 1
            numNodesExpanded = bfsNumNodesExpanded
        elif readData['planner'] == 'a':
            aStarData = aStar(readData['initState'],
                              readData['goalState'], actionList)
            traceData = aStarData.tracePath()
            outputString = traceData['outputString']
            numActions = len(traceData['stateList']) - 1
            numNodesExpanded = aStarNumNodesExpanded
        elif readData['planner'] == 'g':
            gspPlanList = gsp(readData['initState'], readData['goalState'],
                          actionList)
            for stage in gspPlanList:
                action = stage['action']
                assignments = stage['assignments']
                argListString = ''
                for arg in action.argList:
                    argListString += ' ' + str(assignments[arg])
                outputString += '(' + action.name + argListString + ')' + '\n'
            numActions = len(gspPlanList)
            numNodesExpanded = -1

        else:
            print('Invalid planner choice!')

        duration = time.time() - initTime

        if len(outputString) > 0:
            writeFile(fileName[:-4] + '_out.txt', numActions,
                      outputString)
        else:
            print('Error in searching for a plan: no output from planner!'
                  )

        print('\r..........................................................'
              )
        print('Planner: ' + readData['planner'])
        print('Time: ' + str(duration))
        print('Plan length: ' + str(numActions))
        if numNodesExpanded >= 0:
            print('Nodes expanded: ' + str(numNodesExpanded))
        else:
            print('Nodes expanded: ' + 'N.A.')
        print('Output written to: "' + str(fileName[:-4] + '_out.txt"'))
        print('..........................................................'
              )

    return


def checkPlan(plan, startState, goalState):
    """
    Check the validity of a plan `plan`
    given `startState` and `goalState`.
    """

    # TODO: implementation

    pass

# main()
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="p1.aStarNumNodesExpanded" class="name">var <span class="ident">aStarNumNodesExpanded</span></p>
      
  
    <div class="desc"><p>This variable keeps track of total number of nodes expanded in A-Star search.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="p1.bfsNumNodesExpanded" class="name">var <span class="ident">bfsNumNodesExpanded</span></p>
      
  
    <div class="desc"><p>This variable keeps track of total number of nodes expanded in breadth-first search.</p></div>
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="p1.aStar">
    <p>def <span class="ident">aStar</span>(</p><p>startState, goalState, actionList)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a A-Star search on states.
Returns a <code>State</code> object which is equivalent
to the goal state (<code>goalState</code>). A plan can be
obtained by tracing the <code>prevState</code> pointers in states.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.aStar', this);">Show source &equiv;</a></p>
  <div id="source-p1.aStar" class="source">
    <pre><code>def aStar(startState, goalState, actionList):
    """
    Performs a A-Star search on states.
    Returns a `State` object which is equivalent
    to the goal state (`goalState`). A plan can be
    obtained by tracing the `prevState` pointers in states.
    """

    # pdb.set_trace()

    global aStarNumNodesExpanded
    aStarNodesExpanded = 0
    aStarQueue = []

    # Update heuristic value
    # startState.setHeuristicValue(goalState, actionList)

    heappush(aStarQueue, (startState.heuristicValue + startState.depth,
             startState))

    while len(aStarQueue) > 0:
        poppedElement = heappop(aStarQueue)
        poppedState = poppedElement[1]

        print('Searching plans of depth: ' + str(poppedState.depth),
              end='\r')

        if poppedState.isGoalState(goalState):
            return poppedState

        aStarNumNodesExpanded += 1
        neighborList = poppedState.getNextStates(actionList)

        for neighborState in neighborList:
            neighborState.prevState = poppedState
            neighborState.depth = poppedState.depth + 1

            # Update heuristic value

            neighborState.setHeuristicValue(goalState, actionList)
            heappush(aStarQueue, (neighborState.heuristicValue
                     + neighborState.depth, neighborState))

    return None
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.bfs">
    <p>def <span class="ident">bfs</span>(</p><p>startState, goalState, actionList, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a breadth-first search on states.
Returns a <code>State</code> object which is equivalent
to the goal state (<code>goalState</code>). A plan can be
obtained by tracing the <code>prevState</code> pointers in states.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.bfs', this);">Show source &equiv;</a></p>
  <div id="source-p1.bfs" class="source">
    <pre><code>def bfs(
    startState,
    goalState,
    actionList,
    inHeuristicMode=False,
    ):
    """
    Performs a breadth-first search on states.
    Returns a `State` object which is equivalent
    to the goal state (`goalState`). A plan can be
    obtained by tracing the `prevState` pointers in states.
    """

    # pdb.set_trace()

    global bfsNumNodesExpanded
    bfsNumNodesExpanded = 0
    bfsQueue = []
    bfsQueue.append(startState)

    while len(bfsQueue) > 0:
        poppedState = bfsQueue.pop(0)
        print('Searching plans of depth: ' + str(poppedState.depth),
              end='\r')

        if poppedState.isGoalState(goalState, inHeuristicMode):
            return poppedState

        bfsNumNodesExpanded += 1
        neighborList = poppedState.getNextStates(actionList,
                inHeuristicMode)

        for neighborState in neighborList:
            neighborState.prevState = poppedState
            neighborState.depth = poppedState.depth + 1

        bfsQueue.extend(neighborList)

    return None
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.checkPlan">
    <p>def <span class="ident">checkPlan</span>(</p><p>plan, startState, goalState)</p>
    </div>
    

    
  
    <div class="desc"><p>Check the validity of a plan <code>plan</code>
given <code>startState</code> and <code>goalState</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.checkPlan', this);">Show source &equiv;</a></p>
  <div id="source-p1.checkPlan" class="source">
    <pre><code>def checkPlan(plan, startState, goalState):
    """
    Check the validity of a plan `plan`
    given `startState` and `goalState`.
    """

    # TODO: implementation

    pass
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.cmpListNoOrder">
    <p>def <span class="ident">cmpListNoOrder</span>(</p><p>first, second)</p>
    </div>
    

    
  
    <div class="desc"><p>"Deep" compares two lists. Returns <code>True</code> of they are equal, and
<code>False</code> otherwise.
Order of elements in the lists does not matter.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.cmpListNoOrder', this);">Show source &equiv;</a></p>
  <div id="source-p1.cmpListNoOrder" class="source">
    <pre><code>def cmpListNoOrder(first, second):
    """
    "Deep" compares two lists. Returns `True` of they are equal, and
    `False` otherwise.
    Order of elements in the lists does not matter.
    """

    if not len(first) == len(second):
        return False

    dupFirst = list(first)
    dupSecond = list(second)

    for item in dupFirst:
        exists = False
        itemInList = None
        for other in dupSecond:
            if item == other:
                exists = True
                itemInList = other
                break

        if not exists:
            return False

        dupSecond.remove(itemInList)

    return True
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.cmpListWithOrder">
    <p>def <span class="ident">cmpListWithOrder</span>(</p><p>first, second)</p>
    </div>
    

    
  
    <div class="desc"><p>"Deep" compares two lists. Returns <code>True</code> of they are equal, and
<code>False</code> otherwise.
Order of elements in the lists matters.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.cmpListWithOrder', this);">Show source &equiv;</a></p>
  <div id="source-p1.cmpListWithOrder" class="source">
    <pre><code>def cmpListWithOrder(first, second):
    """
    "Deep" compares two lists. Returns `True` of they are equal, and
    `False` otherwise.
    Order of elements in the lists matters.
    """

    if not len(first) == len(second):
        return False

    dupFirst = list(first)
    dupSecond = list(second)

    for ii, item in enumerate(dupFirst):
        if item != dupSecond[ii]:
            return False

    return True
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.getActionsForBlocksWorld">
    <p>def <span class="ident">getActionsForBlocksWorld</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Hardcoded actions for the Blocks World.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.getActionsForBlocksWorld', this);">Show source &equiv;</a></p>
  <div id="source-p1.getActionsForBlocksWorld" class="source">
    <pre><code>def getActionsForBlocksWorld():
    """
    Hardcoded actions for the Blocks World.
    """

    pickBlock = Action('pick', ['block'],
                       [TrueSentence(PropositionTypes.ONTABLE,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.CLEAR,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.EMPTY, [],
                       False)], [TrueSentence(PropositionTypes.HOLD,
                       [Arg(ArgTypes.VARIABLE, 'block', False)],
                       False), TrueSentence(PropositionTypes.CLEAR,
                       [Arg(ArgTypes.VARIABLE, 'block', False)], True),
                       TrueSentence(PropositionTypes.ONTABLE,
                       [Arg(ArgTypes.VARIABLE, 'block', False)], True),
                       TrueSentence(PropositionTypes.EMPTY, [], True)])

    unstackBlockAFromTopOfBlockB = Action('unstack', ['blocka', 'blockb'
            ], [TrueSentence(PropositionTypes.ON,
            [Arg(ArgTypes.VARIABLE, 'blocka', False),
            Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.EMPTY, [], False)],
            [TrueSentence(PropositionTypes.HOLD,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.ON, [Arg(ArgTypes.VARIABLE,
            'blocka', False), Arg(ArgTypes.VARIABLE, 'blockb', False)],
            True), TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], True),
            TrueSentence(PropositionTypes.EMPTY, [], True)])

    releaseBlock = Action('release', ['block'],
                          [TrueSentence(PropositionTypes.HOLD,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False)],
                          [TrueSentence(PropositionTypes.ONTABLE,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False), TrueSentence(PropositionTypes.CLEAR,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          False), TrueSentence(PropositionTypes.HOLD,
                          [Arg(ArgTypes.VARIABLE, 'block', False)],
                          True), TrueSentence(PropositionTypes.EMPTY,
                          [], False)])

    stackBlockAOnTopOfBlockB = Action('stack', ['blocka', 'blockb'],
            [TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], False),
            TrueSentence(PropositionTypes.HOLD, [Arg(ArgTypes.VARIABLE,
            'blocka', False)], False)],
            [TrueSentence(PropositionTypes.ON, [Arg(ArgTypes.VARIABLE,
            'blocka', False), Arg(ArgTypes.VARIABLE, 'blockb', False)],
            False), TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blocka', False)], False),
            TrueSentence(PropositionTypes.HOLD, [Arg(ArgTypes.VARIABLE,
            'blocka', False)], True),
            TrueSentence(PropositionTypes.CLEAR,
            [Arg(ArgTypes.VARIABLE, 'blockb', False)], True),
            TrueSentence(PropositionTypes.EMPTY, [], False)])

    return [pickBlock, unstackBlockAFromTopOfBlockB, releaseBlock,
            stackBlockAOnTopOfBlockB]
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.gsp">
    <p>def <span class="ident">gsp</span>(</p><p>startState, goalState, actionList)</p>
    </div>
    

    
  
    <div class="desc"><p>Does Goal Stack planning.
Returns a plan in the form of a list of dictionaries, in
their logical order in the plan.
The format of returned dictionary is:
    (1) <code>action</code> : element of <code>actionList</code> that has to be applied.
    (2) <code>assignments</code> : assignments used for applying returned action.
No parameters used to call this function are changed.
This function may not terminate (semi-decidable).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.gsp', this);">Show source &equiv;</a></p>
  <div id="source-p1.gsp" class="source">
    <pre><code>def gsp(startState, goalState, actionList):
    """
    Does Goal Stack planning.
    Returns a plan in the form of a list of dictionaries, in
    their logical order in the plan.
    The format of returned dictionary is:
        (1) `action` : element of `actionList` that has to be applied.
        (2) `assignments` : assignments used for applying returned action.
    No parameters used to call this function are changed.
    This function may not terminate (semi-decidable).
    """

    stack = []
    currentState = State(startState.trueSentenceList, \
                        startState.groundTermList)
    planList = []
    nBlocks = len(currentState.groundTermList)

    stack.append(goalState.trueSentenceList)
    for trueSentence in goalState.trueSentenceList:
        stack.append([trueSentence])

    while len(stack) > 0:
        # print("***new***")
        # printList(stack)
        print(str(len(planList)).zfill(3), end = "\r")
        poppedElement = stack.pop()

        if type(poppedElement) is list:

            if not currentState.hasTrueSentences(poppedElement):

                if len(poppedElement) > 1:
                    stack.append(poppedElement)
                    random.shuffle(poppedElement)
                    for trueSentence in poppedElement:
                        stack.append([trueSentence])

                else:
                    newGoalsData = poppedElement[0].getNewGoals(currentState, actionList)

                    if newGoalsData == None:
                        stack = []
                        currentState = State(startState.trueSentenceList, \
                                startState.groundTermList)
                        planList = []
                        stack.append(goalState.trueSentenceList)
                        for trueSentence in goalState.trueSentenceList:
                            stack.append([trueSentence])
                        continue

                    actionDict = dict()
                    actionDict['action'] = newGoalsData['action']
                    actionDict['assignments'] = newGoalsData['assignments']
                    stack.append(actionDict)
                    stack.append(newGoalsData['trueSentenceList'])
                    for trueSentence in newGoalsData['trueSentenceList']:
                        stack.append([trueSentence])
        else:
            action = poppedElement['action']
            assignments = poppedElement['assignments']
            currentState = action.getStateOnActionUtil(currentState, assignments)
            planList.append(poppedElement)
            # printDict(poppedElement)

    return planList
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.main">
    <p>def <span class="ident">main</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Take input argument (a file name), and write soduko solutions
to a file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.main', this);">Show source &equiv;</a></p>
  <div id="source-p1.main" class="source">
    <pre><code>def main():
    """
    Take input argument (a file name), and write soduko solutions
    to a file.
    """

    if len(sys.argv) < 2:
        print('Invalid/insufficient arguments!')
    else:
        actionList = getActionsForBlocksWorld()
        fileName = str(sys.argv[1])
        readData = readFile(fileName)
        traceData = None
        outputString = ''
        numActions = 0
        numNodesExpanded = 0
        global bfsNumNodesExpanded
        global aStarNodesExpanded
        bfsNumNodesExpanded = 0
        aStarNodesExpanded = 0

        initTime = time.time()

        if readData['planner'] == 'f':
            bfsData = bfs(readData['initState'], readData['goalState'],
                          actionList)
            traceData = bfsData.tracePath()
            outputString = traceData['outputString']
            numActions = len(traceData['stateList']) - 1
            numNodesExpanded = bfsNumNodesExpanded
        elif readData['planner'] == 'a':
            aStarData = aStar(readData['initState'],
                              readData['goalState'], actionList)
            traceData = aStarData.tracePath()
            outputString = traceData['outputString']
            numActions = len(traceData['stateList']) - 1
            numNodesExpanded = aStarNumNodesExpanded
        elif readData['planner'] == 'g':
            gspPlanList = gsp(readData['initState'], readData['goalState'],
                          actionList)
            for stage in gspPlanList:
                action = stage['action']
                assignments = stage['assignments']
                argListString = ''
                for arg in action.argList:
                    argListString += ' ' + str(assignments[arg])
                outputString += '(' + action.name + argListString + ')' + '\n'
            numActions = len(gspPlanList)
            numNodesExpanded = -1

        else:
            print('Invalid planner choice!')

        duration = time.time() - initTime

        if len(outputString) > 0:
            writeFile(fileName[:-4] + '_out.txt', numActions,
                      outputString)
        else:
            print('Error in searching for a plan: no output from planner!'
                  )

        print('\r..........................................................'
              )
        print('Planner: ' + readData['planner'])
        print('Time: ' + str(duration))
        print('Plan length: ' + str(numActions))
        if numNodesExpanded >= 0:
            print('Nodes expanded: ' + str(numNodesExpanded))
        else:
            print('Nodes expanded: ' + 'N.A.')
        print('Output written to: "' + str(fileName[:-4] + '_out.txt"'))
        print('..........................................................'
              )

    return
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.printDict">
    <p>def <span class="ident">printDict</span>(</p><p>currentDict)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints a dictionary properly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.printDict', this);">Show source &equiv;</a></p>
  <div id="source-p1.printDict" class="source">
    <pre><code>def printDict(currentDict):
    """
    Prints a dictionary properly.
    """

    for key in currentDict.keys():
        print(str(key) + ': ')
        if type(currentDict[key]) is list:
            printList(currentDict[key])
        elif type(currentDict[key]) is dict:
            printDict(currentDict[key])
        else:
            print(str(currentDict[key]))

        print("")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.printList">
    <p>def <span class="ident">printList</span>(</p><p>currentList)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints a list properly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.printList', this);">Show source &equiv;</a></p>
  <div id="source-p1.printList" class="source">
    <pre><code>def printList(currentList):
    """
    Prints a list properly.
    """

    print("#####")
    for item in currentList:
        if type(item) is list:
            printList(item)
        elif type(item) is dict:
            printDict(item)
        else:
            print(item, end = ", ")

    print("")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.readFile">
    <p>def <span class="ident">readFile</span>(</p><p>fileName)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a dictionary with initial state, final state and
the "mode" of operation as read from the <code>fileName</code> file.
Keys in dictionary are:
'planner', 'initState', 'goalState'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.readFile', this);">Show source &equiv;</a></p>
  <div id="source-p1.readFile" class="source">
    <pre><code>def readFile(fileName):
    """
    Returns a dictionary with initial state, final state and
    the "mode" of operation as read from the `fileName` file.
    Keys in dictionary are:
    'planner', 'initState', 'goalState'.
    """

    retDict = {}

    with open(fileName) as inFile:

        # pdb.set_trace()

        lines = inFile.readlines()
        lines = [line.strip() for line in lines]

        try:
            numberBlocks = int(lines[0])
        except ValueError:
            print('Please tell me the number of blocks!')
            return None
        completeBlockList = []
        for i in range(1, numberBlocks + 1):
            completeBlockList.append(Arg(ArgTypes.TERMINAL, i, False))

        validPlanners = ['f', 'a', 'g']
        if not lines[1] in validPlanners:
            print("Oh! Looks like you want a planner that we don't have!"
                  )
            return None
        retDict['planner'] = lines[1]

        if not lines[2] == 'initial':
            print("Don't know from where the initial state starts!")
            return None
        initState = State([], [])
        words = lines[3].split()
        argList = []
        propositionType = None
        for word in words:
            if word[0] == '(':
                argList = []
                propositionType = word.strip('(')
            else:
                try:
                    argList.append(completeBlockList[int(word.strip(')'
                                   )) - 1])
                except:
                    print("Sorry! Can't read the file!")
                    return None
            if word[-1] == ')':
                initState.addTrueSentence(TrueSentence(propositionType.strip(')'
                        ), argList))

        retDict['initState'] = initState

        if not lines[4] == 'goal':
            print("Don't know from where the goal state starts!")
            return None

        goalState = State([], [])
        words = lines[5].split()
        argList = []
        propositionType = None
        isNegation = False
        for word in words:
            if word[0] == '~':
                isNegation = True
                word = word.strip('~')

            if word[0] == '(':
                argList = []
                propositionType = word.strip('(')
            else:
                try:
                    argList.append(completeBlockList[int(word.strip(')'
                                   )) - 1])
                except:
                    print("Sorry! Can't read the file!")
                    return None
            if word[-1] == ')':
                goalState.addTrueSentence(TrueSentence(propositionType.strip(')'
                        ), argList, isNegation))
                isNegation = False

        retDict['goalState'] = goalState
        return retDict
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="p1.writeFile">
    <p>def <span class="ident">writeFile</span>(</p><p>fileName, numActions, outputString)</p>
    </div>
    

    
  
    <div class="desc"><p>Writes <code>outputString</code> to the given file.
<code>fileName</code> is the pathname of the file to write to.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.writeFile', this);">Show source &equiv;</a></p>
  <div id="source-p1.writeFile" class="source">
    <pre><code>def writeFile(fileName, numActions, outputString):
    """
    Writes `outputString` to the given file.
    `fileName` is the pathname of the file to write to.
    """

    f = open(fileName, 'w')
    f.write(str(numActions) + '\n')
    f.write(outputString)
    f.close()
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="p1.Action" class="name">class <span class="ident">Action</span></p>
      
  
    <div class="desc"><p>This class represents an action and applies, reverses, and
manages all aspects of actions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Action', this);">Show source &equiv;</a></p>
  <div id="source-p1.Action" class="source">
    <pre><code>class Action:

    """
    This class represents an action and applies, reverses, and
    manages all aspects of actions.
    """

    def __init__(
        self,
        name,
        argList,
        preconditionList,
        effectList,
        ):
        """
        Initializes an Action object.
        """

        self.name = name
        """
        Name of the action.
        """

        self.argList = argList
        """
        List of entities on which the action is applied.
        """

        self.preconditionList = list(preconditionList)
        """
        Preconditions: a list of TrueSentence objects
        """

        self.effectList = list(effectList)
        """
        Effects: a list of TrueSentence objects
        """

        self.variableTermList = []
        """
        A list of `Arg` objects in sentences in the `preconditionList` list.
        """

        for precondition in preconditionList:
            for arg in precondition.argList:
                alreadyPresent = False
                for selfArg in self.variableTermList:
                    if arg == selfArg:
                        alreadyPresent = True
                        break
                if not alreadyPresent:
                    self.variableTermList.append(arg)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the Action object.
        """

        retStr = 'Action : ' + self.name + '\n'
        retStr += 'Pre: '
        for item in self.preconditionList:
            retStr += str(item)
        retStr += '\n'
        retStr += 'Eff: '
        for item in self.effectList:
            retStr += str(item)
        retStr += '\n'

        return retStr

    def getStateOnActionUtil(
        self,
        stateObject,
        assignments,
        inHeuristicMode=False,
        ):
        """
        Applies `this` Action to `stateObject` with given `assignments`.
        `assignments` is the dictionary of assignments made.
        `inHeuristicMode` is the mode identifier.
        Returns a new `State` object.
        Does not modify `stateObject`.
        """

        retState = State(stateObject.trueSentenceList,
                         stateObject.groundTermList)
        for trueSentence in self.effectList:
            newTrueSentence = \
                TrueSentence(trueSentence.propositionType, [])
            groundTermList = []
            for variable in trueSentence.argList:
                savedArg = assignments[variable.value]
                # groundTermList.append(Arg(savedArg.type,
                        # savedArg.value, savedArg.isNegation))
                groundTermList.append(savedArg)

            newTrueSentence.argList = groundTermList
            if trueSentence.isNegation:
                if not inHeuristicMode:
                    retState.removeTrueSentence(newTrueSentence)
            else:
                retState.addTrueSentence(newTrueSentence)

        retState.prevAction = self
        retState.prevAssignments = dict(assignments)
        argListString = ''
        for arg in self.argList:
            argListString += ' ' + str(assignments[arg])

        retState.prevPrintData = '(' + self.name + argListString + ')'
        if inHeuristicMode:
            retState.heuristicValue = stateObject.heuristicValue + 1
        return retState

    def getStatesOnApplicationUtil(
        self,
        stateObject,
        unassignedVariableList,
        assignments,
        retList,
        inHeuristicMode=False,
        ):
        """
        Assigns groundterms to unassigned variables in `unassignedVariableList`.
        Returns a list of `State` objects possible after
        application of `this` Action to `stateObject`.
        `assignments` is a dictionary of assignments already made.
        Keys in this are `value` parameters of `Arg` objects.
        Values in this dictionary are `Arg` objects.
        `retList` is a list of `State` objects already generated.
        """

        if len(unassignedVariableList) == 0:

            effectTrueSentencesList = []
            for trueSentence in self.effectList:
                positiveGroundTermList = []
                if trueSentence.isNegation:
                    continue
                for variable in trueSentence.argList:
                    positiveGroundTermList.append(assignments[variable.value])
                effectTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                        positiveGroundTermList))

            if stateObject.hasTrueSentences(effectTrueSentencesList):
                return retList

            groundTermTrueSentencesList = []
            for trueSentence in self.preconditionList:
                groundTermList = []
                for variable in trueSentence.argList:
                    groundTermList.append(assignments[variable.value])
                groundTermTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                        groundTermList))

            if stateObject.hasTrueSentences(groundTermTrueSentencesList):
                if not inHeuristicMode:
                    retList.append(self.getStateOnActionUtil(stateObject,
                                   assignments, inHeuristicMode))
                else:
                    stateObject = \
                        self.getStateOnActionUtil(stateObject,
                            assignments, inHeuristicMode)
                    retList = [stateObject]
            return retList

        else:
            thisVariable = unassignedVariableList.pop()
            for groundTerm in stateObject.groundTermList:
                assignments[thisVariable.value] = groundTerm
                retList = self.getStatesOnApplicationUtil(stateObject,
                        unassignedVariableList, assignments, retList,
                        inHeuristicMode)
                if inHeuristicMode and len(retList) > 0:
                    stateObject = retList[0]
                assignments.pop(thisVariable.value)

            unassignedVariableList.append(thisVariable)
            return retList

    def getStatesOnApplication(self, stateObject,
                               inHeuristicMode=False):
        """
        Generates states after unification to input `stateObject`.
        Returns a list of `State` objects.
        This list may be empty.
        The argument `stateObject` is not modified.
        """

        assignments = {}
        retList = []
        return self.getStatesOnApplicationUtil(stateObject,
                self.variableTermList, assignments, retList,
                inHeuristicMode)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.Action">Action</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="p1.Action.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, argList, preconditionList, effectList)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializes an Action object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Action.__init__', this);">Show source &equiv;</a></p>
  <div id="source-p1.Action.__init__" class="source">
    <pre><code>def __init__(
    self,
    name,
    argList,
    preconditionList,
    effectList,
    ):
    """
    Initializes an Action object.
    """
    self.name = name
    """
    Name of the action.
    """
    self.argList = argList
    """
    List of entities on which the action is applied.
    """
    self.preconditionList = list(preconditionList)
    """
    Preconditions: a list of TrueSentence objects
    """
    self.effectList = list(effectList)
    """
    Effects: a list of TrueSentence objects
    """
    self.variableTermList = []
    """
    A list of `Arg` objects in sentences in the `preconditionList` list.
    """
    for precondition in preconditionList:
        for arg in precondition.argList:
            alreadyPresent = False
            for selfArg in self.variableTermList:
                if arg == selfArg:
                    alreadyPresent = True
                    break
            if not alreadyPresent:
                self.variableTermList.append(arg)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.Action.getStateOnActionUtil">
    <p>def <span class="ident">getStateOnActionUtil</span>(</p><p>self, stateObject, assignments, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Applies <code>this</code> Action to <code>stateObject</code> with given <code>assignments</code>.
<code>assignments</code> is the dictionary of assignments made.
<code>inHeuristicMode</code> is the mode identifier.
Returns a new <code>State</code> object.
Does not modify <code>stateObject</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Action.getStateOnActionUtil', this);">Show source &equiv;</a></p>
  <div id="source-p1.Action.getStateOnActionUtil" class="source">
    <pre><code>def getStateOnActionUtil(
    self,
    stateObject,
    assignments,
    inHeuristicMode=False,
    ):
    """
    Applies `this` Action to `stateObject` with given `assignments`.
    `assignments` is the dictionary of assignments made.
    `inHeuristicMode` is the mode identifier.
    Returns a new `State` object.
    Does not modify `stateObject`.
    """
    retState = State(stateObject.trueSentenceList,
                     stateObject.groundTermList)
    for trueSentence in self.effectList:
        newTrueSentence = \
            TrueSentence(trueSentence.propositionType, [])
        groundTermList = []
        for variable in trueSentence.argList:
            savedArg = assignments[variable.value]
            # groundTermList.append(Arg(savedArg.type,
                    # savedArg.value, savedArg.isNegation))
            groundTermList.append(savedArg)
        newTrueSentence.argList = groundTermList
        if trueSentence.isNegation:
            if not inHeuristicMode:
                retState.removeTrueSentence(newTrueSentence)
        else:
            retState.addTrueSentence(newTrueSentence)
    retState.prevAction = self
    retState.prevAssignments = dict(assignments)
    argListString = ''
    for arg in self.argList:
        argListString += ' ' + str(assignments[arg])
    retState.prevPrintData = '(' + self.name + argListString + ')'
    if inHeuristicMode:
        retState.heuristicValue = stateObject.heuristicValue + 1
    return retState
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.Action.getStatesOnApplication">
    <p>def <span class="ident">getStatesOnApplication</span>(</p><p>self, stateObject, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Generates states after unification to input <code>stateObject</code>.
Returns a list of <code>State</code> objects.
This list may be empty.
The argument <code>stateObject</code> is not modified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Action.getStatesOnApplication', this);">Show source &equiv;</a></p>
  <div id="source-p1.Action.getStatesOnApplication" class="source">
    <pre><code>def getStatesOnApplication(self, stateObject,
                           inHeuristicMode=False):
    """
    Generates states after unification to input `stateObject`.
    Returns a list of `State` objects.
    This list may be empty.
    The argument `stateObject` is not modified.
    """
    assignments = {}
    retList = []
    return self.getStatesOnApplicationUtil(stateObject,
            self.variableTermList, assignments, retList,
            inHeuristicMode)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.Action.getStatesOnApplicationUtil">
    <p>def <span class="ident">getStatesOnApplicationUtil</span>(</p><p>self, stateObject, unassignedVariableList, assignments, retList, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Assigns groundterms to unassigned variables in <code>unassignedVariableList</code>.
Returns a list of <code>State</code> objects possible after
application of <code>this</code> Action to <code>stateObject</code>.
<code>assignments</code> is a dictionary of assignments already made.
Keys in this are <code>value</code> parameters of <code>Arg</code> objects.
Values in this dictionary are <code>Arg</code> objects.
<code>retList</code> is a list of <code>State</code> objects already generated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Action.getStatesOnApplicationUtil', this);">Show source &equiv;</a></p>
  <div id="source-p1.Action.getStatesOnApplicationUtil" class="source">
    <pre><code>def getStatesOnApplicationUtil(
    self,
    stateObject,
    unassignedVariableList,
    assignments,
    retList,
    inHeuristicMode=False,
    ):
    """
    Assigns groundterms to unassigned variables in `unassignedVariableList`.
    Returns a list of `State` objects possible after
    application of `this` Action to `stateObject`.
    `assignments` is a dictionary of assignments already made.
    Keys in this are `value` parameters of `Arg` objects.
    Values in this dictionary are `Arg` objects.
    `retList` is a list of `State` objects already generated.
    """
    if len(unassignedVariableList) == 0:
        effectTrueSentencesList = []
        for trueSentence in self.effectList:
            positiveGroundTermList = []
            if trueSentence.isNegation:
                continue
            for variable in trueSentence.argList:
                positiveGroundTermList.append(assignments[variable.value])
            effectTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                    positiveGroundTermList))
        if stateObject.hasTrueSentences(effectTrueSentencesList):
            return retList
        groundTermTrueSentencesList = []
        for trueSentence in self.preconditionList:
            groundTermList = []
            for variable in trueSentence.argList:
                groundTermList.append(assignments[variable.value])
            groundTermTrueSentencesList.append(TrueSentence(trueSentence.propositionType,
                    groundTermList))
        if stateObject.hasTrueSentences(groundTermTrueSentencesList):
            if not inHeuristicMode:
                retList.append(self.getStateOnActionUtil(stateObject,
                               assignments, inHeuristicMode))
            else:
                stateObject = \
                    self.getStateOnActionUtil(stateObject,
                        assignments, inHeuristicMode)
                retList = [stateObject]
        return retList
    else:
        thisVariable = unassignedVariableList.pop()
        for groundTerm in stateObject.groundTermList:
            assignments[thisVariable.value] = groundTerm
            retList = self.getStatesOnApplicationUtil(stateObject,
                    unassignedVariableList, assignments, retList,
                    inHeuristicMode)
            if inHeuristicMode and len(retList) > 0:
                stateObject = retList[0]
            assignments.pop(thisVariable.value)
        unassignedVariableList.append(thisVariable)
        return retList
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="p1.Action.argList" class="name">var <span class="ident">argList</span></p>
            

            
  
    <div class="desc"><p>List of entities on which the action is applied.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Action.effectList" class="name">var <span class="ident">effectList</span></p>
            

            
  
    <div class="desc"><p>Effects: a list of TrueSentence objects</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Action.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>Name of the action.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Action.preconditionList" class="name">var <span class="ident">preconditionList</span></p>
            

            
  
    <div class="desc"><p>Preconditions: a list of TrueSentence objects</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Action.variableTermList" class="name">var <span class="ident">variableTermList</span></p>
            

            
  
    <div class="desc"><p>A list of <code>Arg</code> objects in sentences in the <code>preconditionList</code> list.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="p1.Arg" class="name">class <span class="ident">Arg</span></p>
      
  
    <div class="desc"><p>This class represents an argument.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Arg', this);">Show source &equiv;</a></p>
  <div id="source-p1.Arg" class="source">
    <pre><code>class Arg:
    """
    This class represents an argument.
    """

    def __init__(
        self,
        argType,
        argValue,
        isNegation,
        ):
        """
        Initializes the argument using `argType` and `argValue`.
        """

        self.type = argType
        """
        Type of the argument.
        """

        self.value = argValue
        """
        Value of the argument.
        """

        self.isNegation = isNegation
        """
        Helps in distinguishing between positive and negative literals.
        """

    def __str__(self):
        """
        Returns a human-friendly representation of
        the argument.
        """

        retStr = ''

        if self.isNegation:
            retStr += '~'

        if self.type == ArgTypes.TERMINAL:
            retStr += str(self.value).upper()
        else:
            retStr += str(self.value).lower()

        return retStr

    def isVariable(self):
        """
        Returns true if 'Arg' object is a variable.
        """

        return self.type == ArgTypes.VARIABLE

    def __eq__(self, other):
        """
        Checks the equality of two `Arg` objects.
        """

        return self.type == other.type and self.value == other.value \
            and self.isNegation == other.isNegation

    def __ne__(self, other):
        """
        Checks the inequality of two `Arg` objects.
        """

        return not self.__eq__(other)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.Arg">Arg</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="p1.Arg.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, argType, argValue, isNegation)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializes the argument using <code>argType</code> and <code>argValue</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Arg.__init__', this);">Show source &equiv;</a></p>
  <div id="source-p1.Arg.__init__" class="source">
    <pre><code>def __init__(
    self,
    argType,
    argValue,
    isNegation,
    ):
    """
    Initializes the argument using `argType` and `argValue`.
    """
    self.type = argType
    """
    Type of the argument.
    """
    self.value = argValue
    """
    Value of the argument.
    """
    self.isNegation = isNegation
    """
    Helps in distinguishing between positive and negative literals.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.Arg.isVariable">
    <p>def <span class="ident">isVariable</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns true if 'Arg' object is a variable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.Arg.isVariable', this);">Show source &equiv;</a></p>
  <div id="source-p1.Arg.isVariable" class="source">
    <pre><code>def isVariable(self):
    """
    Returns true if 'Arg' object is a variable.
    """
    return self.type == ArgTypes.VARIABLE
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="p1.Arg.isNegation" class="name">var <span class="ident">isNegation</span></p>
            

            
  
    <div class="desc"><p>Helps in distinguishing between positive and negative literals.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Arg.type" class="name">var <span class="ident">type</span></p>
            

            
  
    <div class="desc"><p>Type of the argument.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.Arg.value" class="name">var <span class="ident">value</span></p>
            

            
  
    <div class="desc"><p>Value of the argument.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="p1.ArgTypes" class="name">class <span class="ident">ArgTypes</span></p>
      
  
    <div class="desc"><p>This class contains constants for different types of arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.ArgTypes', this);">Show source &equiv;</a></p>
  <div id="source-p1.ArgTypes" class="source">
    <pre><code>class ArgTypes:

    """
    This class contains constants for different types of arguments.
    """

    VARIABLE = 0
    TERMINAL = 1
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.ArgTypes">ArgTypes</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="p1.ArgTypes.TERMINAL" class="name">var <span class="ident">TERMINAL</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.ArgTypes.VARIABLE" class="name">var <span class="ident">VARIABLE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="p1.PropositionTypes" class="name">class <span class="ident">PropositionTypes</span></p>
      
  
    <div class="desc"><p>This class contains constants for different types of propositions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.PropositionTypes', this);">Show source &equiv;</a></p>
  <div id="source-p1.PropositionTypes" class="source">
    <pre><code>class PropositionTypes:
    """
    This class contains constants for different types of propositions.
    """

    ON = 'on'
    ONTABLE = 'ontable'
    CLEAR = 'clear'
    HOLD = 'hold'
    EMPTY = 'empty'
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.PropositionTypes">PropositionTypes</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="p1.PropositionTypes.CLEAR" class="name">var <span class="ident">CLEAR</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.PropositionTypes.EMPTY" class="name">var <span class="ident">EMPTY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.PropositionTypes.HOLD" class="name">var <span class="ident">HOLD</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.PropositionTypes.ON" class="name">var <span class="ident">ON</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.PropositionTypes.ONTABLE" class="name">var <span class="ident">ONTABLE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="p1.State" class="name">class <span class="ident">State</span></p>
      
  
    <div class="desc"><p>This class represents the current state.
This represents a conjuction of <code>TrueSentence</code> objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State', this);">Show source &equiv;</a></p>
  <div id="source-p1.State" class="source">
    <pre><code>class State:
    """
    This class represents the current state.
    This represents a conjuction of `TrueSentence` objects.
    """

    def __init__(self, trueSentenceList, groundTermList):
        """
        Initializes a `State` object.
        """

        self.trueSentenceList = list(trueSentenceList)
        """
        A list of objects of class TrueSentence.
        """

        self.groundTermList = list(groundTermList)
        """
        A list of ground `Arg` objects in sentences in the `trueSentenceList` list.
        """

        self.prevState = None
        """
        This variable is used to figure out a path after searching is done.
        """

        self.prevAction = None
        """
        Stores the action taken to reach to this `State`.
        """

        self.prevAssignments = None
        """
        Stores the assignments made in the previous state to reach this state.
        """

        self.prevPrintData = ''
        """
        Stores the string representing a combination of `self.prevAction`
        and `self.prevAssignments`.
        """

        self.depth = 0
        """
        Housekeeping variable used to print progress.
        """

        self.heuristicValue = 0
        """
        Value used in A-Star search.
        """

    def tracePath(self):
        """
        Trace path from initial state to `self`.
        Returns a dictionary with:
        (1) A string with actions (in order) in plan.
        (2) A list of states in the plan.
        """

        pathList = []
        current = self

        while current:
            pathList.append(current)
            current = current.prevState

        pathList.reverse()

        retStr = ''
        for state in pathList:
            retStr += state.prevPrintData + '\n'

        retDict = dict()
        retDict['outputString'] = retStr.strip()
        retDict['stateList'] = pathList

        return retDict

    def addTrueSentence(self, trueSentence):
        """
        Adds the `trueSentence` object to the state.
        """

        for arg in trueSentence.argList:
            if arg.isVariable():
                return

        for arg in trueSentence.argList:
            alreadyPresent = False
            for selfArg in self.groundTermList:
                if arg == selfArg:
                    alreadyPresent = True
                    break
            if not alreadyPresent:
                self.groundTermList.append(arg)

        self.trueSentenceList.append(trueSentence)

    def removeTrueSentence(self, trueSentenceArg):
        """
        Removes all objects "equal to" the `trueSentence` object from the state.
        """

        self.trueSentenceList = [trueSentence for trueSentence in
                                 self.trueSentenceList
                                 if not trueSentence == trueSentenceArg]

    def hasTrueSentences(self, trueSentenceList):
        """
        Checks if all the sentences in `trueSentenceList` exist in the state.
        If they do not, returns `False`.
        """

        for newSentence in trueSentenceList:
            isPresent = False
            for selfSentence in self.trueSentenceList:
                if selfSentence == newSentence:
                    isPresent = True
                    break
            if not isPresent:
                return False

        return True

    def isGoalState(self, goalState, inHeuristicMode=False):
        """
        Checks if `state` is a goal state by comparing
        it to `goalState`. Returns `True` if it is, and `False` otherwise.
        Essentially compares two states.
        """

        if not inHeuristicMode:
            return goalState == self
        else:
            return self.hasTrueSentences(goalState.trueSentenceList)

    def __eq__(self, other):
        """
        Checks equality of one `State` object with another.
        """

        return cmpListNoOrder(self.trueSentenceList, other.trueSentenceList)

    def __ne__(self, other):
        """
        Checks the inequality of two `State` objects.
        """

        return not self.__eq__(other)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the current state.
        """

        retStr = ''

        for trueSentence in self.trueSentenceList:
            retStr += str(trueSentence) + ' \n'

        retStr += 'Previous Action : ' + self.prevPrintData + '\n' \
            + str(self.prevAction)
        return retStr

    def setHeuristicValue(self, goalState, actionList):
        """
        Sets the heuristic value of this object.
        """

        # self.heuristicValue = bfs(self, goalState, actionList, True).depth

        currState = State(self.trueSentenceList, self.groundTermList)
        count = 0

        while True:
            for action in actionList:
                retList = action.getStatesOnApplication(currState, True)
                if len(retList) > 0:
                    currState = retList[0]
                count += 1
                if currState.hasTrueSentences(goalState.trueSentenceList):
                    self.heuristicValue = count
                    return

        # self.heuristicValue = currState.heuristicValue
        self.heuristicValue = count

    def getNextStates(self, actionList, inHeuristicMode=False):
        """
        Applies each action in `actionList` to the `self` state
        and returns all the states generated.
        """

        retList = []

        for action in actionList:
            retList.extend(action.getStatesOnApplication(self,
                           inHeuristicMode))

        return retList
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.State">State</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="p1.State.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, trueSentenceList, groundTermList)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializes a <code>State</code> object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.__init__', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.__init__" class="source">
    <pre><code>def __init__(self, trueSentenceList, groundTermList):
    """
    Initializes a `State` object.
    """
    self.trueSentenceList = list(trueSentenceList)
    """
    A list of objects of class TrueSentence.
    """
    self.groundTermList = list(groundTermList)
    """
    A list of ground `Arg` objects in sentences in the `trueSentenceList` list.
    """
    self.prevState = None
    """
    This variable is used to figure out a path after searching is done.
    """
    self.prevAction = None
    """
    Stores the action taken to reach to this `State`.
    """
    self.prevAssignments = None
    """
    Stores the assignments made in the previous state to reach this state.
    """
    self.prevPrintData = ''
    """
    Stores the string representing a combination of `self.prevAction`
    and `self.prevAssignments`.
    """
    self.depth = 0
    """
    Housekeeping variable used to print progress.
    """
    self.heuristicValue = 0
    """
    Value used in A-Star search.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.addTrueSentence">
    <p>def <span class="ident">addTrueSentence</span>(</p><p>self, trueSentence)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds the <code>trueSentence</code> object to the state.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.addTrueSentence', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.addTrueSentence" class="source">
    <pre><code>def addTrueSentence(self, trueSentence):
    """
    Adds the `trueSentence` object to the state.
    """
    for arg in trueSentence.argList:
        if arg.isVariable():
            return
    for arg in trueSentence.argList:
        alreadyPresent = False
        for selfArg in self.groundTermList:
            if arg == selfArg:
                alreadyPresent = True
                break
        if not alreadyPresent:
            self.groundTermList.append(arg)
    self.trueSentenceList.append(trueSentence)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.getNextStates">
    <p>def <span class="ident">getNextStates</span>(</p><p>self, actionList, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Applies each action in <code>actionList</code> to the <code>self</code> state
and returns all the states generated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.getNextStates', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.getNextStates" class="source">
    <pre><code>def getNextStates(self, actionList, inHeuristicMode=False):
    """
    Applies each action in `actionList` to the `self` state
    and returns all the states generated.
    """
    retList = []
    for action in actionList:
        retList.extend(action.getStatesOnApplication(self,
                       inHeuristicMode))
    return retList
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.hasTrueSentences">
    <p>def <span class="ident">hasTrueSentences</span>(</p><p>self, trueSentenceList)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if all the sentences in <code>trueSentenceList</code> exist in the state.
If they do not, returns <code>False</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.hasTrueSentences', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.hasTrueSentences" class="source">
    <pre><code>def hasTrueSentences(self, trueSentenceList):
    """
    Checks if all the sentences in `trueSentenceList` exist in the state.
    If they do not, returns `False`.
    """
    for newSentence in trueSentenceList:
        isPresent = False
        for selfSentence in self.trueSentenceList:
            if selfSentence == newSentence:
                isPresent = True
                break
        if not isPresent:
            return False
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.isGoalState">
    <p>def <span class="ident">isGoalState</span>(</p><p>self, goalState, inHeuristicMode=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if <code>state</code> is a goal state by comparing
it to <code>goalState</code>. Returns <code>True</code> if it is, and <code>False</code> otherwise.
Essentially compares two states.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.isGoalState', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.isGoalState" class="source">
    <pre><code>def isGoalState(self, goalState, inHeuristicMode=False):
    """
    Checks if `state` is a goal state by comparing
    it to `goalState`. Returns `True` if it is, and `False` otherwise.
    Essentially compares two states.
    """
    if not inHeuristicMode:
        return goalState == self
    else:
        return self.hasTrueSentences(goalState.trueSentenceList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.removeTrueSentence">
    <p>def <span class="ident">removeTrueSentence</span>(</p><p>self, trueSentenceArg)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes all objects "equal to" the <code>trueSentence</code> object from the state.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.removeTrueSentence', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.removeTrueSentence" class="source">
    <pre><code>def removeTrueSentence(self, trueSentenceArg):
    """
    Removes all objects "equal to" the `trueSentence` object from the state.
    """
    self.trueSentenceList = [trueSentence for trueSentence in
                             self.trueSentenceList
                             if not trueSentence == trueSentenceArg]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.setHeuristicValue">
    <p>def <span class="ident">setHeuristicValue</span>(</p><p>self, goalState, actionList)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the heuristic value of this object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.setHeuristicValue', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.setHeuristicValue" class="source">
    <pre><code>def setHeuristicValue(self, goalState, actionList):
    """
    Sets the heuristic value of this object.
    """
    # self.heuristicValue = bfs(self, goalState, actionList, True).depth
    currState = State(self.trueSentenceList, self.groundTermList)
    count = 0
    while True:
        for action in actionList:
            retList = action.getStatesOnApplication(currState, True)
            if len(retList) > 0:
                currState = retList[0]
            count += 1
            if currState.hasTrueSentences(goalState.trueSentenceList):
                self.heuristicValue = count
                return
    # self.heuristicValue = currState.heuristicValue
    self.heuristicValue = count
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.State.tracePath">
    <p>def <span class="ident">tracePath</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Trace path from initial state to <code>self</code>.
Returns a dictionary with:
(1) A string with actions (in order) in plan.
(2) A list of states in the plan.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.State.tracePath', this);">Show source &equiv;</a></p>
  <div id="source-p1.State.tracePath" class="source">
    <pre><code>def tracePath(self):
    """
    Trace path from initial state to `self`.
    Returns a dictionary with:
    (1) A string with actions (in order) in plan.
    (2) A list of states in the plan.
    """
    pathList = []
    current = self
    while current:
        pathList.append(current)
        current = current.prevState
    pathList.reverse()
    retStr = ''
    for state in pathList:
        retStr += state.prevPrintData + '\n'
    retDict = dict()
    retDict['outputString'] = retStr.strip()
    retDict['stateList'] = pathList
    return retDict
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="p1.State.depth" class="name">var <span class="ident">depth</span></p>
            

            
  
    <div class="desc"><p>Housekeeping variable used to print progress.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.groundTermList" class="name">var <span class="ident">groundTermList</span></p>
            

            
  
    <div class="desc"><p>A list of ground <code>Arg</code> objects in sentences in the <code>trueSentenceList</code> list.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.heuristicValue" class="name">var <span class="ident">heuristicValue</span></p>
            

            
  
    <div class="desc"><p>Value used in A-Star search.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.prevAction" class="name">var <span class="ident">prevAction</span></p>
            

            
  
    <div class="desc"><p>Stores the action taken to reach to this <code>State</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.prevAssignments" class="name">var <span class="ident">prevAssignments</span></p>
            

            
  
    <div class="desc"><p>Stores the assignments made in the previous state to reach this state.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.prevPrintData" class="name">var <span class="ident">prevPrintData</span></p>
            

            
  
    <div class="desc"><p>Stores the string representing a combination of <code>self.prevAction</code>
and <code>self.prevAssignments</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.prevState" class="name">var <span class="ident">prevState</span></p>
            

            
  
    <div class="desc"><p>This variable is used to figure out a path after searching is done.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.State.trueSentenceList" class="name">var <span class="ident">trueSentenceList</span></p>
            

            
  
    <div class="desc"><p>A list of objects of class TrueSentence.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="p1.TrueSentence" class="name">class <span class="ident">TrueSentence</span></p>
      
  
    <div class="desc"><p>This class represents a sentence whose truth value is "True".</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.TrueSentence', this);">Show source &equiv;</a></p>
  <div id="source-p1.TrueSentence" class="source">
    <pre><code>class TrueSentence:
    """
    This class represents a sentence whose truth value is "True".
    """

    def __init__(
        self,
        propositionType,
        argList,
        isNegation=False,
        ):
        """
        Initializes a TrueSentence object.
        """

        self.propositionType = propositionType
        """
        Type of proposition.
        """

        self.argList = list(argList)
        """
        List of Arg objects for the proposition.
        """

        self.isNegation = isNegation
        """
        \"Adds\" a negation sign before the statement.
        """

        self.truthValue = False
        """
        Truth value of the statement for Goal Stack planner.
        """

    def __eq__(self, other):
        """
        Check equality of `TrueSentence` objects.
        """

        return self.propositionType == other.propositionType \
            and self.isNegation == other.isNegation \
            and cmpListWithOrder(self.argList, other.argList)

    def __ne__(self, other):
        """
        Checks the inequality of two `TrueSentence` objects.
        """

        return not self.__eq__(other)

    def __str__(self):
        """
        Returns a human-friendly representation of
        the TrueSentence object.
        """

        resultStr = ''

        if self.isNegation:
            resultStr += '~'

        resultStr += '('
        resultStr += self.propositionType

        for arg in self.argList:
            resultStr += ' '
            resultStr += str(arg)
        resultStr = resultStr.strip()
        resultStr += ') '

        return resultStr

    def getNewGoals(self, currState, actionList):
        """
        Returns a dictionary of data required for new goals of GSP.
        Format of returned dictionary is :
            `trueSentenceList` : list of new `TrueSentence` objects.
            `action` : element of `actionList` that has to be applied.
            `assignments` : assignments used for applying returned action.
        `currState` is the current `State`.
        `actionList` is the list of possible actions in given world.
        Returns `None` if the goal is not reachable.
        """

        pickAction = actionList[0]
        unstackAction = actionList[1]
        releaseAction = actionList[2]
        stackAction = actionList[3]

        retDict = {}
        possibleActions = []
        assignments = {}

        possibleAssignments = list(currState.groundTermList)
        if self.propositionType == PropositionTypes.ON:
            nextAction = stackAction
        elif self.propositionType == PropositionTypes.ONTABLE:
            nextAction = releaseAction
        elif self.propositionType == PropositionTypes.EMPTY:
            nextAction = releaseAction
        elif self.propositionType == PropositionTypes.HOLD:
            checkSentence = TrueSentence(PropositionTypes.ONTABLE, self.argList, False)
            if currState.hasTrueSentences([checkSentence]):
                nextAction = pickAction
            else:
                nextAction = unstackAction
        elif self.propositionType == PropositionTypes.CLEAR:
            checkSentence = TrueSentence(PropositionTypes.HOLD, self.argList, False)
            if currState.hasTrueSentences([checkSentence]):
                nextAction = releaseAction
            else:
                nextAction = unstackAction
        else:
            return None

        for trueSentence in nextAction.effectList:
            if trueSentence.propositionType == self.propositionType \
                    and self.isNegation == trueSentence.isNegation:
                for ii in range(len(self.argList)):
                    assignments[trueSentence.argList[ii].value] = \
                            self.argList[ii]
                if nextAction == unstackAction:
                    if self.propositionType == PropositionTypes.HOLD:
                        for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.ON, \
                                    [self.argList[0], terminal], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break
                    elif self.propositionType == PropositionTypes.CLEAR:
                        for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.ON, \
                                    [terminal, self.argList[0]], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break
                    else:
                        return None
                elif self.propositionType == PropositionTypes.EMPTY:
                    for terminal in possibleAssignments:
                            checkSentence = TrueSentence(PropositionTypes.HOLD, \
                                    [terminal], False)
                            if currState.hasTrueSentences([checkSentence]):
                                possibleAssignments = [terminal]
                                break

                break


#             for trueSentence in action.effectList:
#                 if trueSentence.propositionType == self.propositionType \
#                         and self.isNegation == trueSentence.isNegation:
#                     assignments = {}
#                     possibleAssignments = list(currState.groundTermList)
#                     for ii in range(len(trueSentence.argList)):
#                         assignments[trueSentence.argList[ii].value] = \
#                                 self.argList[ii]
#                         possibleAssignments.remove(self.argList[ii])
#                     possibleActions.append([action, assignments, possibleAssignments])

#         if len(possibleActions) == 0:
#             return None

#         random.shuffle(possibleActions)
#         nextAction = possibleActions[0][0]
#         assignments = possibleActions[0][1]
#         possibleAssignments = possibleActions[0][2]
        retDict['action'] = nextAction

        for arg in nextAction.variableTermList:
            if not assignments.has_key(arg.value):
                if len(possibleAssignments) == 0:
                    break
                randomIndex = random.randrange(0, len(possibleAssignments))
                assignments[arg.value] = possibleAssignments[randomIndex]
                possibleAssignments.pop(randomIndex)

        retDict['assignments'] = assignments

        retTrueList = []
        for trueSentence in nextAction.preconditionList:
            assignedSentence = TrueSentence(trueSentence.propositionType, \
                    trueSentence.argList, trueSentence.isNegation)
            newArgList = []
            for arg in assignedSentence.argList:
                if arg.isVariable():
                    newArgList.append(assignments[arg.value])
                else:
                    newArgList.append(arg)
            assignedSentence.argList = newArgList
            retTrueList.append(assignedSentence)

        retDict['trueSentenceList'] = retTrueList

        # print("***new***")
#         print("State:")
#         print(currState)
#         print("Input:")
#         print(self)
#         printDict(retDict)

        return retDict
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#p1.TrueSentence">TrueSentence</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="p1.TrueSentence.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, propositionType, argList, isNegation=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializes a TrueSentence object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.TrueSentence.__init__', this);">Show source &equiv;</a></p>
  <div id="source-p1.TrueSentence.__init__" class="source">
    <pre><code>def __init__(
    self,
    propositionType,
    argList,
    isNegation=False,
    ):
    """
    Initializes a TrueSentence object.
    """
    self.propositionType = propositionType
    """
    Type of proposition.
    """
    self.argList = list(argList)
    """
    List of Arg objects for the proposition.
    """
    self.isNegation = isNegation
    """
    \"Adds\" a negation sign before the statement.
    """
    self.truthValue = False
    """
    Truth value of the statement for Goal Stack planner.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="p1.TrueSentence.getNewGoals">
    <p>def <span class="ident">getNewGoals</span>(</p><p>self, currState, actionList)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a dictionary of data required for new goals of GSP.
Format of returned dictionary is :
    <code>trueSentenceList</code> : list of new <code>TrueSentence</code> objects.
    <code>action</code> : element of <code>actionList</code> that has to be applied.
    <code>assignments</code> : assignments used for applying returned action.
<code>currState</code> is the current <code>State</code>.
<code>actionList</code> is the list of possible actions in given world.
Returns <code>None</code> if the goal is not reachable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-p1.TrueSentence.getNewGoals', this);">Show source &equiv;</a></p>
  <div id="source-p1.TrueSentence.getNewGoals" class="source">
    <pre><code>def getNewGoals(self, currState, actionList):
    """
    Returns a dictionary of data required for new goals of GSP.
    Format of returned dictionary is :
        `trueSentenceList` : list of new `TrueSentence` objects.
        `action` : element of `actionList` that has to be applied.
        `assignments` : assignments used for applying returned action.
    `currState` is the current `State`.
    `actionList` is the list of possible actions in given world.
    Returns `None` if the goal is not reachable.
    """
    pickAction = actionList[0]
    unstackAction = actionList[1]
    releaseAction = actionList[2]
    stackAction = actionList[3]
    retDict = {}
    possibleActions = []
    assignments = {}
    possibleAssignments = list(currState.groundTermList)
    if self.propositionType == PropositionTypes.ON:
        nextAction = stackAction
    elif self.propositionType == PropositionTypes.ONTABLE:
        nextAction = releaseAction
    elif self.propositionType == PropositionTypes.EMPTY:
        nextAction = releaseAction
    elif self.propositionType == PropositionTypes.HOLD:
        checkSentence = TrueSentence(PropositionTypes.ONTABLE, self.argList, False)
        if currState.hasTrueSentences([checkSentence]):
            nextAction = pickAction
        else:
            nextAction = unstackAction
    elif self.propositionType == PropositionTypes.CLEAR:
        checkSentence = TrueSentence(PropositionTypes.HOLD, self.argList, False)
        if currState.hasTrueSentences([checkSentence]):
            nextAction = releaseAction
        else:
            nextAction = unstackAction
    else:
        return None
    for trueSentence in nextAction.effectList:
        if trueSentence.propositionType == self.propositionType \
                and self.isNegation == trueSentence.isNegation:
            for ii in range(len(self.argList)):
                assignments[trueSentence.argList[ii].value] = \
                        self.argList[ii]
            if nextAction == unstackAction:
                if self.propositionType == PropositionTypes.HOLD:
                    for terminal in possibleAssignments:
                        checkSentence = TrueSentence(PropositionTypes.ON, \
                                [self.argList[0], terminal], False)
                        if currState.hasTrueSentences([checkSentence]):
                            possibleAssignments = [terminal]
                            break
                elif self.propositionType == PropositionTypes.CLEAR:
                    for terminal in possibleAssignments:
                        checkSentence = TrueSentence(PropositionTypes.ON, \
                                [terminal, self.argList[0]], False)
                        if currState.hasTrueSentences([checkSentence]):
                            possibleAssignments = [terminal]
                            break
                else:
                    return None
            elif self.propositionType == PropositionTypes.EMPTY:
                for terminal in possibleAssignments:
                        checkSentence = TrueSentence(PropositionTypes.HOLD, \
                                [terminal], False)
                        if currState.hasTrueSentences([checkSentence]):
                            possibleAssignments = [terminal]
                            break
            break
          for trueSentence in action.effectList:
              if trueSentence.propositionType == self.propositionType \
                      and self.isNegation == trueSentence.isNegation:
                  assignments = {}
                  possibleAssignments = list(currState.groundTermList)
                  for ii in range(len(trueSentence.argList)):
                      assignments[trueSentence.argList[ii].value] = \
                              self.argList[ii]
                      possibleAssignments.remove(self.argList[ii])
                  possibleActions.append([action, assignments, possibleAssignments])
      if len(possibleActions) == 0:
          return None
      random.shuffle(possibleActions)
      nextAction = possibleActions[0][0]
      assignments = possibleActions[0][1]
      possibleAssignments = possibleActions[0][2]
    retDict['action'] = nextAction
    for arg in nextAction.variableTermList:
        if not assignments.has_key(arg.value):
            if len(possibleAssignments) == 0:
                break
            randomIndex = random.randrange(0, len(possibleAssignments))
            assignments[arg.value] = possibleAssignments[randomIndex]
            possibleAssignments.pop(randomIndex)
    retDict['assignments'] = assignments
    retTrueList = []
    for trueSentence in nextAction.preconditionList:
        assignedSentence = TrueSentence(trueSentence.propositionType, \
                trueSentence.argList, trueSentence.isNegation)
        newArgList = []
        for arg in assignedSentence.argList:
            if arg.isVariable():
                newArgList.append(assignments[arg.value])
            else:
                newArgList.append(arg)
        assignedSentence.argList = newArgList
        retTrueList.append(assignedSentence)
    retDict['trueSentenceList'] = retTrueList
    # print("***new***")
      print("State:")
      print(currState)
      print("Input:")
      print(self)
      printDict(retDict)
    return retDict
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="p1.TrueSentence.argList" class="name">var <span class="ident">argList</span></p>
            

            
  
    <div class="desc"><p>List of Arg objects for the proposition.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.TrueSentence.isNegation" class="name">var <span class="ident">isNegation</span></p>
            

            
  
    <div class="desc"><p>"Adds" a negation sign before the statement.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.TrueSentence.propositionType" class="name">var <span class="ident">propositionType</span></p>
            

            
  
    <div class="desc"><p>Type of proposition.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="p1.TrueSentence.truthValue" class="name">var <span class="ident">truthValue</span></p>
            

            
  
    <div class="desc"><p>Truth value of the statement for Goal Stack planner.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
